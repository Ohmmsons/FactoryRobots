@startuml
class RobotManager {
- ArrayList<Robot> subscribers
- Queue<Point> requests
- void addSubscriber(Robot)
- void removeSubscriber(Robot)
+ void update()
+ void notify(Robot,RobotPowerState)
+ void addRequest(Point)
}
class Planner {
- TrajectoryPopulation population
- double pm
- double pa
- double pr
- Random generator
- ArrayList<Shape> obstacles
+ Trajectory findTrajectory()
}
class Circle {
- double r
- double shortestDistance(LineSegment,Point)
+ boolean surrounds(Point)
+ boolean isIntercepted(LineSegment)
}
enum RobotPowerState {
+  MOVING
+  CHARGING
+  STANDBY
}



abstract class Shape {
# Point[] points
+ {abstract}boolean surrounds(Point)
+ {abstract}boolean isIntercepted(LineSegment)
+ Point[] getPoints()
}
class Robot {
- Point currentPosition
- Random generator
- double energy
- RobotPowerState powerState
- Point chargingStation
- Iterator<Point> trajectoryPointIterator
- RobotManager manager
- boolean needToCharge
- DeliveryMap deliveryMap
+ void subscribeToManager(RobotManager)
+ double getEnergy()
+ void update()
+ boolean canReachDestination(Trajectory)
+ void setPath(Trajectory)
+ String toString()
- void moveToNextPosition()
- void goToChargingStation()
+ Trajectory findTrajectory(Point,Point)
+ Point getCurrentPosition()
}

class Simulator {
- SimulatorUI ui
- boolean validInputCheck(DeliveryMap,Point)
+ void startSimulation()
}
class TrajectoryPopulation {
- ArrayList<Trajectory> individuals
- ArrayList<Shape> obstacles
- Random generator
+ ArrayList<Trajectory> getIndividuals()
+ String populationInfo()
+ void sortByFitness()
+ String toString()
+ TrajectoryPopulation tournament()
}
class Polygon {
+ boolean surrounds(Point)
+ boolean isIntercepted(LineSegment)
}
interface SimulatorUI {
~ int askForNumberOfObstacles()
~ Point askForPoint()
~ void displayRobotStatus(int,List<Robot>)
~ void displayErrorMessage(String)
}
class DeliveryMap {
- ArrayList<Shape> obstacles
+ void addObstacle(Shape)
+ void removeObstacle(Point)
+ boolean isDeliveryPointValid(Point)
+ ArrayList<Shape> getObstacles()
}
class Rectangle {
- boolean isOrthogonal(Point,Point,Point)
}
class Trajectory {
- ArrayList<Point> points
- double length
+ Random generator
- ArrayList<Shape> obstacles
+ String toString()
+ int nCollisions()
+ double fitness()
+ Trajectory[] crossover(Trajectory)
+ void mutate(double)
+ boolean equals(Object)
+ void addPoint(double)
+ void removePoint(double)
+ int hashCode()
+ ArrayList<Point> getPoints()
+ double getLength()
}
class Triangle {
}
class SimulatorCLI {
- Scanner sc
+ int askForNumberOfObstacles()
+ Point askForPoint()
+ void displayRobotStatus(int,List<Robot>)
+ void displayErrorMessage(String)
}
class SimulatorGUI {
+ int askForNumberOfObstacles()
+ Point askForPoint()
+ void displayRobotStatus(int,List<Robot>)
+ void displayErrorMessage(String)
}

class LineSegment{
-Point p1
-Point p2
-boolean ccw(Point a, Point b, Point c)
+boolean intercepts(LineSegment other)
+double length
}
class Point{
-int x
-int y
+String toString()
+int hashCode()
+double dist(Point p)
}



Shape <|-- Circle
Shape <|-- Polygon
Polygon <|-- Rectangle
Polygon <|-- Triangle
SimulatorUI - Simulator
Robot *-- RobotPowerState
TrajectoryPopulation *-- Trajectory
Planner *-- TrajectoryPopulation
Robot *-- Planner
Simulator *-- DeliveryMap
Simulator *-- RobotManager
Simulator *-- Robot
RobotManager o-- Robot
DeliveryMap o-- Shape
Simulator *-- Shape
LineSegment o-- Point
Shape o-- Point
Trajectory *-- Point
Planner - DeliveryMap
SimulatorUI <|.. SimulatorCLI
SimulatorUI <|.. SimulatorGUI
@enduml